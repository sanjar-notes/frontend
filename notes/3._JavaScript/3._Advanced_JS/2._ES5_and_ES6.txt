Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.6
Creation-Date: 2020-07-14T15:34:11+05:30

====== 2. ES5 and ES6 ======
Created Tuesday 14 July 2020

**"There is nothing static about being a web-developer, everything is improving".**
* HTML, CSS are JS constantly improving.
* Even browsers are being updated.
* New libraries are made, existing ones are being improved.
--------------------
* JS was created by Netscape, and everybody started using it.
* Netscape submitted JS to an organization called ECMA International, for standardization. This is followed by all the browsers.
* Now formally called ECMAScript, it interchangeably used with JavaScript.
* ES5 and ES6 introduced new features which make coding very easy and fun.
--------------------
**Not all browsers support ES5 and ES6 right now, is it practical to learn and use the standard right now?**
**Explanation:** Yes, some new features of ESx are not currently supported by all browsers. But we can still use them, we'll use a **compiler** to obtain the most supported version of ECMAScript from the latest ESx code. A popular compiler is **Babel**, it works with the latest ESx. **Don't worry about the version.**
There are two important operations when handling two versions:
	1. Polyfilling - Representing new functionality in old code. No syntax changes should be present between new and old. Only functionality changes.
	2. Transpiling - There are new syntax changes, and the current code needs to be represented in old syntax. Functionality does not matter here.
* Babel does both transpiling and polyfilling.
{{./pasted_image.png?width=300}} {{./pasted_image001.png}}
The new standards are produce clean and short code, which is easy to understand.
Don't be afraid.
--------------------

==== 1. let and const ====
* **let** was introduced in ES6.
* use **const** if you won't reuse the variable, makes the code more consistent.

==== 2. Destructuring objects ====
	1. Can declare variables with name(same as properties) outside the object. They are assigned the correponding property value from the object. The reference variable names and properties should be **same, **though** order** does not matter. __Useful if only one object is involved.__
		{{./pasted_image002.png?width=300}}
	* Destructuring can take place in parameter places. Calling f(obj) where f is defined as f({a, b, c});
{{{code: lang="js" linenumbers="True"
const {prop2, prop1, prop11} = obj; // all properties placed correctly, order is not important 
// we can do property = x;

// WHY IS THE NEW WAY BETTER? In the old way, this would be
const prop1 = obj.prop1; // n lines like these for n properties - 4 words per property
...
const propn = obj.propn;

// But in ES6
const { prop1, prop2, ...... propn } = obj; // no object and prop duplicates, RHS is completely omitted.
// Consequenly, code size 1/4 th the original - 1 word per property
}}}
	


==== 3. Object Properties ====
	1. Can keep property name as the string equivalent of a non-//Object// variable. 
		* Syntax: Place the existing variable inside square brackets.
		{{./pasted_image003.png?width=400}} 
		{{./pasted_image004.png}}
		* List within lists are treated as one list. This shortening is not meant for lists, actually. Strings are unchanged.
		* Using an **Object** is not helpful, the property name is object Object.
		* Helps in objects with properties name based on user input. **Dynamic properties**.
		* We can get the property by doing obj[var_name], no need of strings here. It is done internally.
	2. Can keep property name the same as the variable name.
		* Syntax: just write the variable, without the value part.
		{{./pasted_image005.png}}
		{{./pasted_image006.png}}
		* Halves the code.

==== 4. Template strings ====
	* Our friend from Python.
	* Syntax: Use **back-ticks** instead of the quotes, with the template part written as ${var_name}
	{{./pasted_image007.png}}
	{{./pasted_image008.png}}
==== 5. Symbol data type ====
	* Useful when working with objects.
	* Used to create properties in objects which are invisible to the object owner.
	* This is important if different people work on the same object. Separation of concerns is the goal, symbols avoid properties to clash, if the object is handled by two scripts.
	* There is a global symbol registry, syntax, Symbol.for('id') is used to get the key for id, this is useful if we want some symbols to be the same in a team where a project has many teams.
	* Symbol() don't auto-convert to strings, which is why obj[id1] is different for different people.
{{{code: lang="js" linenumbers="True"
id = Symbol('id'); // desciption does not affect the hash value
const obj = {
	[id]: 23; 
}

// we can add our own properties to an existing object
id1 = Symbol();
obj[id1] = 231; // not accessible to the original user even if he uses property name as id1
}}}
	

==== 6. Arrow functions ====
	* Similar to lambda functions in C++, except the symbol(=>). Place arguments in ().
	* For one liners, all - **return**, **{} **and **;**(except for end of statement) are unnecesary. JS takes care of it.
	* For multi-liners, treat the {} block as any other function block. returns undefined if return in absent.
	* For single arguments only - no need of argument parenthesis. const 2x = num => num*2; is enough. For no-argument and multi-argument, we do need them.
	* **Syntax **(arg1, arg2) => ____ or (arg1, arg2) => {};
{{{code: lang="js" linenumbers="True"
const f = num => num*2;	// no 'return' and '{}' allowed for one liners
console.log(f);	// returns the value

// multi-iners must have {}, and a return(if they return something);
const f = () => console.log('Hello');
console.log('World'); // returns undefined
}
const f = (a, b) => {
	a*2 = b; 
	return a+b; 
}; // 

(()=>console.log(2))(); // running it
}}}
	
	* **Why do it?** -4 letters for each anonymous function, i.e cleaner code.
	{{./pasted_image009.png}}
	* **Make it a habit to ditch **//function **keyword**//** for throwaway and/or one-liner(use const) functions.**
	* Arrow functions bind the object with the function, this is a core difference from function, which require explicit binding.

==== 7. use strict; ====
* We can limit the flexibility of [[https://johnresig.com/blog/ecmascript-5-strict-mode-json-and-more/|things]] using strict mode for **whole scripts** or **functions**.
* syntax
{{{code: lang="js" linenumbers="True"
"use strict"; // for the whole script

function f()
{
	"use strict"; // for the function
	// code 
}
}}}

--------------------
[[./practice.js]]
