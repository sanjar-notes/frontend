Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.6
Creation-Date: 2020-07-15T17:55:09+05:30

====== 3. Advanced Functions ======
Created Wednesday 15 July 2020

1. Keep the functions as their own universe. Use ''const'' and avoid using ''function'' keyword as much as possible.
2. **Closures** - An inner function is returned but, it remembers the parents scope. This can be used to create secure counters. 
	* Why secure ? **Two inner functions are not the same, they are actually instances(which store the context).**
	{{./pasted_image001.png}}
	{{./pasted_image.png}}
	* Closures help us avoid global variables, and they are very useful.
	* The outer function is used only once.
3. **Currying** - //A [[https://medium.com/javascript-scene/curry-and-function-composition-2c208d774983|curried]] function is a function that takes multiple arguments one at a time.// All functions in the chain are different, with the contexts building as we go inside(âˆ´ closure), call pattern is a singly linked list. 
	* All parts are one liners, so chain them directly, without {}.
	* Function invocation should be like: f(a)(b)(c) also called point-free-style
	* This helps us reuse some of the outer context, i.e const x = f(a)(b); now we can use the contexts a and b, and have x(c) directly - **ability to create specialized functions.**
	* **Why do this** ? - Saves us the pain of writing the same arguments many time, and have simple-looking unary functions.
{{{code: lang="js" linenumbers="True"
const f = (a) => (b) => (c) => {/*code involving a, b and c */};
// we need a,b,c1 and a, b, c2 ... f, b, cn some n values, not an array

/// Old approach

/*code involving*/
f(a, b, ci); // a, b which may be irrelevant as compared to ci, i=1 to n


// new approach

f1 = f(a)(b); // include a comment - under environment a and b
/// only relevant variable(s) are mentioned
f1(ci); // only relevant examples - looks clean and simple 
}}}

	* Currying is highly incentivized in JS, there are functions which help debug curried functions.
4. **Composition** - Writing functions where the input of the outer function is the output of the inner function, and this is true for all. Implementing f(g(h(x))) using main_func(f, g)(arg). 
	Syntax: 
{{{code: lang="js" linenumbers="True"
const compose_function(f, g) = (a) => f(g(a)); //done
const f = // define f as a unary function
const g = // a unary function
// compose_function itself has two arguments
// compose_function(f, g) has one argument
console.log(compose_func(f, g)(a));
}}}

	* Accumulation of context is optional.
	* **Why do this?** To avoid obfuscation and ugly code when we want composition, which is by nature ugly(lots of commas).
	* Currying vs Composition - Currying is a multi-argument system and composition is multi-function(not multi-purpose) system.
5. Our functions should be **pure.** 
	* They should have only one purpose.
	* They should be free from side-effects(i.e change to external variables), as much as possible.
	* We always return something.
	* This makes our code deterministic(each function is a mathematical function, not just a relation), and consequently more robust.
