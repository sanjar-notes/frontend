Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.6
Creation-Date: 2020-07-16T17:35:16+05:30

====== 4. Advanced Arrays ======
Created Thursday 16 July 2020

===== Ellipsis(...) Operator =====
There are two very different uses of (...):
1. Iterable unpacking -  "spread operator".
2. Packing to iterable - "rest parameter/element".

=== 1. Spread operator ===
* Purpose - unpack iterables.
* Syntax - ''...iter'' exposes all elements, comma separated. Can be placed inside ''[]'' or ''{}''.
* No in place effect.
* Uses:
	* Basic unpacking - ''[1, 2, ...x]'', where ''x'' is an existing iterable.
	* Concatenation - ''[...x, ...y]''. A shorthand for the array ''concat'' function.
	* Function call(elements as params) - ''f(...[1, 2, 3]);'' is equivalent to ''f(1, 2, 3)''. Extraneous elements(to the right) are ignored, if parameters are less.
	* Copy an array - ''let x = [1, 2], y = [...x];''
* How this works - syntax sugar.

=== 2. Rest parameter/element ===
* Purpose - pack elements, to an array.
* Syntax - There is a slight variation
	* Rest param - ''f(a, b, ...x)''
	* Rest element - ''[a, b, ...x] = iter'', must use a ''[]'' or ''{}''.
* Gotcha - only the last param/element can be a rest param/element, ergo, there can only be one.
* Uses:
	* Varidic function definition - ''f(a, b, ...theArgs)'', ''theArgs'' will be an array.
	* Rest element - ''[a, ...b] = new Set([1, 2, 3])'', result ''a = 1'', ''b = [2, 3]''.
* Variadic functions were possible before ES6 too - you had to use the ''arguments'' object, which is not an array and was therefore difficult to work with. Rest param solved this problem.
* How this works? - Rest element is a simple syntax sugar. For functions, an enclosing [] is placed around the param list by the interpreter, ''arguments'' as rvalue, like so: ''[a, b, ...c] = arguments;''. Thus, we get ''c'' as a array.
https://www.youtube.com/watch?v=R8rmfD9Y5-c&ab_channel=WebDevSimplified FIXME

=== How is spread operator, rest param and destructuring related? ===
* All 3 have different purpose:
	1. Spread operator - unpack elements.
	2. Rest param/element - pack elements.
	3. Destructuring - initialize variable(//s//).
* Destructuring can work with multiple values, other 2 don't.
* It is simple.
--------------------

===== Map, filter and reduce =====

=== 1. Map ===
* Purpose - store f(ele) for each element, in a **map object**.
* Syntax - ''arr.map(f)''; where f can be a function in any form.
* Assume an argument when defining f.
* f(ele) is computed and stored for each element. ''undefined'' is stored if ''f'' returns nothing.
* The map object is index subscriptable.
{{./pasted_image.png}}

=== 2. Filter ===
* Purpose - returns an iterable of elements for which f(ele) is true.
* Syntax - same as map.
{{./pasted_image001.png}}

=== 3. Reduce ===
* Purpose - Accumulates the result by running f(accum,ele) for each element.
* Syntax - ''arr.reduce(f, accum_start=0)''
* You must have //accumulator// and //element// as parameters of ''f'', in order.
{{{code: lang="js" linenumbers="True"
const arr = [1, 2, 3]
const res = arr.reduce(((accum, ele)=> accum + ele), accum_init_value); // 0 if unspecified
// same as doing accum = accum + ele each time
}}}

* Remember update accum inside f().
Note: 
* All the quick for functions - **forEach**, **map**, **filter** and **reduce** work sequentially by default. They can be made parallel, however.
* Iteration number is available all **forEach**, **map** and **filter **- as the second parameter of ''f''. This is optional.

=== Why use map, filter or reduce ===
* Map, filter and reduce help us to make our code functionally pure(deterministic).
* ''map'' and ''filter'' return an iterable objects of outputs, while ''filter'' returns a single value.
* Use these anytime we need loops for small things.
* forEach is different, it returns nothing.

--------------------

===== Something or Everything =====
* Purpose - concise code.
* Given a criteria and an array, there are 3 possibilities. The criteria holds for:
	1. //every// element
	2. //some// element
	3. no element - same as **not(for all)**. Duplicate of 1.
* Consquently, JS has two array methods:
	1. ''every''
	2. ''some''
* About the functions:
	* Syntax: myArray.''every(criteriaFunc(ele, idx){})''. Similarly for ''some''.
	* You can access index as the 2nd param.
	* Working: ''every'' stops at first violation. ''some'' stops at first validation.
	* Time complexity - Î˜(n)
